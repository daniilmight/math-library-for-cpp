#ifndef DM_MATH_LIB_H
#define DM_MATH_LIB_H

// Объявление заголовочного файла, предотвращающее множественное включение.

// Общие переменные, вынесенные за функции
const double pi = 3.14159265358979323846; // Константа pi
const double e = 2.718281828459045235;     // Константа e (число Эйлера)
const double eps = 1e-15;                        // Точность вычислений

// Функция для вычисления модуля значения числа.
double dmAbs(double x) {
    return (x < 0) ? -x : x; // Возвращает модуль числа
}

// Функция для возведения числа в степень.
double dmPow(double base, int exponent) {
    double result = 1.0; // Инициализация результата
    for (int i = 0; i < exponent; ++i) {
        result *= base; // Умножение базы на себя exponent раз
    }
    return result;
}

// Функция для вычисления остатка от деления
double dmMod(double x, double y) {
    return x - y * int(x / y); // Возвращает остаток от деления x на y
}

// Функция для вычисления синуса угла в радианах.
double dmSin(double x)
{
    int sign = (x < 0) ? -1 : 1; // Определение знака угла

    // Приводим значение угла к интервалу [0, 2*pi) для обеспечения периодичности синуса.
    x = dmMod(dmAbs(x), 2 * pi);

    // Если угол находится в третьей или четвертой четверти, преобразуем его в эквивалентный угол в второй или первой четверти, соответственно.
    if (x > pi) {
        x -= pi; // Уменьшаем значение угла на pi.
        sign *= -1; // Меняем знак.
    }

    // Инициализируем переменные для суммы ряда и текущего члена ряда.
    double sum = x, term = x; // Инициализация переменных для ряда Тейлора

    // Итеративно вычисляем члены ряда Тейлора для синуса, пока текущий член по абсолютному значению больше заданной точности eps.
    for (int n = 3; dmAbs(term) > eps; n += 2) {
        // Вычисляем следующий член ряда Тейлора для синуса и добавляем его к сумме.
        term = -term * x * x / n / (n - 1); // Обновляем текущий член ряда.
        sum += term; // Обновляем сумму ряда.
    }

    // Возвращаем сумму ряда, умноженную на знак угла, чтобы сохранить правильный знак синуса.
    return sum * sign;

}

// Функция для вычисления косинуса угла в радианах.
double dmCos(double x)
{
    // Приводим значение угла к интервалу [0, 2*pi) для обеспечения периодичности косинуса.
    x = dmMod(dmAbs(x), 2 * pi);

    // Инициализируем переменные для суммы ряда и текущего члена ряда.
    double sum = 1, term = 1;

    // Итеративно вычисляем члены ряда Тейлора для косинуса.
    // Пока текущий член ряда по абсолютному значению больше заданной точности eps, продолжаем итерации.
    for (int n = 0; dmAbs(term) > eps; n++) {
        // Вычисляем числитель для следующего члена ряда: произведение текущего члена на квадрат значения угла x и смена знака.
        term = -(term * x * x) / ((2 * n + 2) * (2 * n + 1)); // Обновляем текущий член ряда.

        // Добавляем следующий член ряда к сумме.
        sum += term; // Обновляем сумму ряда.
    }
    return sum;
}

// Функция для вычисления натурального логарифма.
double dmLn(double x) {
    // Проверка на недопустимые значения
    if (x <= 0) {
        return 0;  // Возвращаем 0, если x меньше или равно 0 (NaN)
    }

    // Приведение значения x к разумному диапазону [0.25, 1.0] для уменьшения количества итераций в ряду Тейлора.
    int power_adjust = 0; // Инициализируем счетчик сдвига степени
    while (x > 1.0) {
        x /= e; // Делим x на e (основание натурального логарифма) и увеличиваем power_adjust
        power_adjust++;
    }
    while (x < 0.25) {
        x *= e; // Умножаем x на e и уменьшаем power_adjust
        power_adjust--;
    }

    // Вычисление натурального логарифма с помощью ряда Тейлора
    x -= 1.0; // Вычитаем 1 из x
    double sum = 0.0, sign = 1.0, term = x; // Инициализируем переменные для ряда Тейлора
    for (int k = 1; k <= 20; k++) {
        sum += term * sign / k; // Добавляем следующий член ряда Тейлора к сумме
        term *= x; // Умножаем term на x
        sign = -sign; // Меняем знак sign
    }

    // Комбинирование результата с power_adjust и возврат
    return sum + power_adjust; // Возвращаем результат с учетом сдвига степени
}

// Функция для вычисления логарифма с заданным основанием.
double dmLog(double x, double base) {
    if (base <= 0 || x <= 0) {
        return 0.0; // Логарифм не определен для x <= 0 или base <= 0
    }

    double result = dmLn(x) / dmLn(base); // Вычисление логарифма с помощью формулы замены основания
    return result;
}

// Функция для вычисления квадратного корня числа.
double dmSqrt(double x) {
    if (x < 0) {
        return 0.0; // Возвращаем 0, если входное число отрицательное, так как квадратный корень не определен для отрицательных чисел
    }

    double guess = x; // Начальное предположение устанавливается равным входному числу
    double newGuess; // Переменная для хранения нового предположения
    int maxIterations = 1000; // Максимальное количество итераций для избежания зацикливания

    // Итерационный процесс метода Ньютона для нахождения квадратного корня
    while (maxIterations--) {
        newGuess = 0.5 * (guess + x / guess); // Улучшение предположения по методу Ньютона
        if (dmAbs(newGuess - guess) < eps) {
            return newGuess; // Возвращение при достижении необходимой точности
        }
        guess = newGuess; // Обновление предположения для следующей итерации
    }

    return guess; // Возвращение последнего предположения после превышения максимального числа итераций
}


#endif // DM_MATH_LIB_H
